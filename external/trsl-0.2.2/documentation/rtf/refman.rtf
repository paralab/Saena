{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\comment Begining font list}
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\comment begin colors}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\comment Beginning style list}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Template Range Sampling Library {\comment startProjectNumber }
 {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\qc 0.2.2}  \par
}{\comment endProjectNumber }
}Template Range Sampling Library}
{\comment Generated byDoxgyen. }
{\creatim \yr2011\mo4\dy6\hr11\min43\sec14}
}{\comment end of infoblock}
\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
{\comment begin title page}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version <center>0.2.2</center>\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page{\comment End title page}
{\comment Table of contents}
\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
{\comment Beginning Body of RTF Document}
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Main Page\par \pard\plain 
{\tc \v Main Page}
{\comment begin include index.rtf}
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\qc {\f2 http://trsl.sourceforge.net/}} \par
TRSL is a C++ library that implements several sampling schemes behind an (STL-like) iterator interface. The library may be used e.g. in particle filtering or probabilistic inference frameworks. For an overview of the functionalities provided by TRSL, refer to the {\b Products}  page.\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
News
\par}
{\tc\tcl2 \v News}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
2011-04-06 \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Released TRSL 0.2.2. This release contains minor updates, see {\b Version History}  for a list of changes.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
2008-05-21 \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid The Boost Software License is now {\f2 Open Source} (certified by OSI since Feb. 2008). \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
2008-05-18 \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Released TRSL 0.2.1. This release contains minor updates only, see {\b Version History}  for a list of changes.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
2008-03-27 \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid TRSL 0.2.0 is out. See {\b Version History}  for a list of changes.  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
2008-01-02 \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid TRSL 0.1.1 is out. See {\b Version History}  for a list of changes.  \par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
License
\par}
{\tc\tcl2 \v License}
TRSL is distributed under the {\f2 Boost Software License} (BSL). BSL is a {\f2 GPL-compatible free-software} license, very similar to the BSD license and the MIT license; see {\f2 Boost Software License Background}. BSL is also {\f2 open-source}; see {\f2 Boost Software License 1.0} on the {\f2 Open Source Initiative} website.\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Source
\par}
{\tc\tcl2 \v Source}
TRSL is in a usable state. However, as its version number suggests, it is likely to grow and change interface in the future.\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\b Downloads}   \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Releases are available at the Sourceforge {\f2 download page}. The latest sources are available through Subversion:\par{\f2 svn co {\f2 https://trsl.svn.sourceforge.net/svnroot/trsl/trunk} {\b trsl}} \par
\par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\b Project Services}   \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Sourceforge {\f2 project page}.\par
\par}
TRSL is meant to be OS Portable. It has been tested on Linux and MacOS X with GCC 4 and LLVM 2.8 (with clang). If anyone tries it with a different compiler/platform, {\f2 please comment}!\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Feedback
\par}
{\tc\tcl2 \v Feedback}
The preferred method of communication is currently the Sourceforge {\f2 forums} (anonymous posts allowed).\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Products
\par}
{\tc\tcl2 \v Products}
See the {\b Products}  page for the complete list of functionalities offered by TRSL.\par
The central TRSL product is {\b trsl::is_picked_systematic}, a predicate functor to use in combination with {\b trsl::persistent_filter_iterator} to form a {\i sample iterator} . The sample iterator accesses a population of elements through a range defined by a pair of Forward Iterators (begin/end), and provides on-the-fly iteration through a sample of the population.\par
Let us assume a particle filter implementation, which manages a population of particles ({\f2 struct Particle \{ weight; x; y; \}} ) stored in a container {\f2 ParticleCollection} . The following bit of code shows an example of how to iterate through a sample of the population after having implemented {\f2 ParticleCollection::sample_begin(size_t)}  and {\f2 ParticleCollection::sample_end()}  using e.g. {\b trsl::is_picked_systematic}.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid const size_t POPULATION_SIZE = 100;{\comment (lineBreak)}
\par
const size_t SAMPLE_SIZE = 10;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//-----------------------//{\comment (lineBreak)}
\par
// Generate a population //{\comment (lineBreak)}
\par
//-----------------------//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
ParticleCollection population;{\comment (lineBreak)}
\par
for (size_t i = 0; i < POPULATION_SIZE; ++i){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
  Particle p(double(rand())/RAND_MAX,  // weight{\comment (lineBreak)}
\par
             double(rand())/RAND_MAX,  // position (x){\comment (lineBreak)}
\par
             double(rand())/RAND_MAX); // position (y){\comment (lineBreak)}
\par
  population.add(p);{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//----------------------------//{\comment (lineBreak)}
\par
// Sample from the population //{\comment (lineBreak)}
\par
//----------------------------//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
ParticleCollection sample;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//-- population contains 100 elements. --//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
for (ParticleCollection::const_sample_iterator{\comment (lineBreak)}
\par
       si = population.sample_begin(SAMPLE_SIZE),{\comment (lineBreak)}
\par
       se = population.sample_end();{\comment (lineBreak)}
\par
     si != se; ++si){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
  Particle p = *si;{\comment (lineBreak)}
\par
  p.setWeight(1);{\comment (lineBreak)}
\par
  sample.add(p);{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  // ... or do something else with *si ...{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//-- sample contains 10 elements. --//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
assert(sample.size() == SAMPLE_SIZE);{\comment (lineBreak)}
\par
\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Authors
\par}
{\tc\tcl2 \v Authors}
TRSL is developped by {\f2 Renaud Detry}.\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Credits
\par}
{\tc\tcl2 \v Credits}
TRSL is based on the excellent {\f2 Boost Iterator Library}.\par
Several concept implementations (e.g. accessors) are inspired from {\f2 libkdtree++}. \par}
}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include index.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
{\comment begin include group__products.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Products{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Products}
{\xe \v Products}
{\comment writeAnchor (group__products)}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This module presents the functionalities offered by TRSL.\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Systematic Sampling
\par}
{\tc\tcl2 \v Systematic Sampling}
Systematic sampling is provided through {\b trsl::is_picked_systematic}, a predicate functor to use in combination with {\b trsl::persistent_filter_iterator} to form a {\i sample iterator} . The sample iterator accesses a population of elements through a range defined by a pair of Forward Iterators (begin/end), and provides on-the-fly iteration through a sample of the population.\par
Systematic sampling may perform very badly if the order in which the input population is presented is following a pattern. If a pattern is likely to occur in the population, the user may want to pipe the sample iterator {\i after}  a {\b trsl::random_permutation_iterator}, or use is_picked_systematic with ppfilter_iterator. The resulting iterator effectively implements {\i probability sampling} . The price to pay for probability sampling is a {\i Random Access Iterator} . While persistent_filter_iterator will work e.g. with {\f2 std::list} , ppfilter_iterator requires e.g. {\f2 std::vector}  or {\f2 std::deque} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b trsl_example1.cpp}  for a basic example.\par
}{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\b Implementation:} \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b trsl::is_picked_systematic}, {\b trsl::persistent_filter_iterator}, {\b trsl::ppfilter_iterator}.\par}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Range Reordering
\par}
{\tc\tcl2 \v Range Reordering}
Iteration through an index-based reordering of a range can be obtained with {\b trsl::reorder_iterator}. TRSL provides several functions that generate reorder iterators for common reorderings.\par
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Random Permutation
\par}
{\tc\tcl3 \v Random Permutation}
{\b trsl::random_permutation_iterator} provides an iterator over a random permutation of a range.\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\b Implementation:} \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b trsl::reorder_iterator}, {\b trsl::random_permutation_iterator}.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b trsl_example2.cpp}  for a basic example.\par
}\par}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Sorted Permutation
\par}
{\tc\tcl3 \v Sorted Permutation}
{\b trsl::sort_iterator} provides an iterator over a sorted permutation of a range.\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\b Implementation:} \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b trsl::reorder_iterator}, {\b trsl::sort_iterator}.\par}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
 \par}
\par}
}{\comment endFile}
{\comment end include group__products.rtf}
\par \pard\plain 
{\comment begin include group__accessor.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Accessors{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Accessors}
{\xe \v Accessors}
{\comment writeAnchor (group__accessor)}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Accessors are usually called at least once for each element of the accessed collection. Hence, they should be designed carefully in every situation where performance is an issue. For example, one can gain a lot by having the compiler inline accessors.\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Accessor Types
\par}
{\tc\tcl2 \v Accessor Types}
This section describes different types of accessor. In the following, we assume elements to be {\f2 Particle} s. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  class Particle{\comment (lineBreak)}
\par
 \{{\comment (lineBreak)}
\par
 public:{\comment (lineBreak)}
\par
   Particle(double weight, double x, double y) :{\comment (lineBreak)}
\par
     x_(x), y_(y), weight_(weight) \{\}{\comment (lineBreak)}
\par
   {\comment (lineBreak)}
\par
   void setWeight(const double weight) \{ weight_ = weight; \}{\comment (lineBreak)}
\par
   double getWeight() const \{ return weight_; \};{\comment (lineBreak)}
\par
 {\comment (lineBreak)}
\par
 private:{\comment (lineBreak)}
\par
   double x_;{\comment (lineBreak)}
\par
   double y_;{\comment (lineBreak)}
\par
   double weight_;{\comment (lineBreak)}
\par
 \};{\comment (lineBreak)}
\par
}
\par
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functor
\par}
{\tc\tcl3 \v Functor}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  struct functor_weight_accessor \{{\comment (lineBreak)}
\par
   double operator() (const Particle& p) const{\comment (lineBreak)}
\par
   \{ return p.getWeight(); \}{\comment (lineBreak)}
\par
 \};{\comment (lineBreak)}
\par
}
\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor Type \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 functor_weight_accessor}  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor object, to pass to the object that needs access \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 functor_weight_accessor()}  \par}
An example of functor accessor is {\b trsl::weight_accessor}, which always returns 1 -- useful if elements have uniform weights.\par}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Pointer
\par}
{\tc\tcl3 \v Function Pointer}
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  double function_pointer_weight_accessor(const Particle& p){\comment (lineBreak)}
\par
 \{ return p.getWeight(); \}{\comment (lineBreak)}
\par
}
\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor Type \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 std::pointer_to_unary_function<const Particle&, double>}  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor object, to pass to the object that needs access \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 std::ptr_fun(function_pointer_weight_accessor)}  \par}
\par}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Method Pointer
\par}
{\tc\tcl3 \v Method Pointer}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor Type \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 std::const_mem_fun_ref_t<double, Particle>}  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor object, to pass to the object that needs access \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 std::mem_fun_ref(&Particle::getWeight)}  \par}
Method pointer is currently the default in {\b trsl::is_picked_systematic} (but subject to change, see {\b Discussion} ). The implementation used in TRSL is not std::const_mem_fun_ref_t however, but {\b trsl::mp_weight_accessor} which allows a default construction without implying segfault when called -- that comes with a price, see {\b trsl::mp_weight_accessor}.\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor Type \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 trsl::mp_weight_accessor<double, Particle>}  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Accessor object, to pass to the object that needs access \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\f2 &Particle::getWeight}  (implicit conversion) \par}
The pointer to {\f2 getWeight}  implicitly constructs a {\b trsl::mp_weight_accessor}. (Why does the std counterpart have an explicit constructor?)\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Discussion
\par}
{\tc\tcl2 \v Discussion}
I had the impression that GCC was able to inline fuctions from pointers. Performance tests on accessors (see {\f2 tests/accessor_efficiency.cpp} ) tend to contradict this impression. With {\f2 -03}  optimization, the functor accessor is twice as fast as other accessors. Please comment if you know more about this. \par}
}{\comment endFile}
{\comment end include group__accessor.rtf}
\par \pard\plain 
{\comment begin include group__random.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Random Number Generators{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Random Number Generators}
{\xe \v Random Number Generators}
{\comment writeAnchor (group__random)}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Some of the classes in TRSL need random numbers. If a class needs only one random number (e.g. {\b trsl::is_picked_systematic}), it is generally possible to provide it directly. It's then up to the user to take care of the random generator.\par
Another possibility is to use TRSL-internal random capabilities, implemented using system random number generators. By default, the {\f2 std::rand}  function is used.\par
The {\f2 std::rand}  generator that comes with BSD systems (including MacOS X) has slight issues -- e.g. some bits of the returned numbers are not usable. However, BSD systems provide a second, better random number generator through a function named {\f2 ::random} . This function will be used instead of {\f2 std::rand}  if TRSL_USE_BSD_BETTER_RANDOM_GENERATOR is defined. In that case, seeding should be done through {\f2 ::srandom} . Note that in GNU/Linux systems, both {\f2 std::rand}  and {\f2 ::random}  use the same generator.\par
When relying on TRSL-internal {\f2 std::rand/::random}  calls, the user is still responsible for seeding the random number generator. \par
}{\comment endFile}
{\comment end include group__random.rtf}
\par \pard\plain 
{\comment begin include group__faq.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
F.A.Q.{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v F.A.Q.}
{\xe \v F.A.Q.}
{\comment writeAnchor (group__faq)}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
What if my population data structure doesn't provide iterators?
\par}
{\tc\tcl2 \v What if my population data structure doesn't provide iterators?}
Write one :-). {\f2 Boost Iterator Facade} makes it really easy.\par
However, keep in mind that pointers are indeed iterators. If your population data structure guarantees to store elements contiguously, and if you can get a pointer to the first element, you have iterators already. See {\b trsl_example2.cpp}  for an example with a C array. \par}
}{\comment endFile}
{\comment end include group__faq.rtf}
\par \pard\plain 
{\comment begin include group__notes.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Notes{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Notes}
{\xe \v Notes}
{\comment writeAnchor (group__notes)}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Naming Conventions
\par}
{\tc\tcl2 \v Naming Conventions}
Since TRSL is closely tied to Boost, it is intended to follow naming conventions from {\f2 Boost Design and Programming Guidelines}, at least for public symbols. \par}
}{\comment endFile}
{\comment end include group__notes.rtf}
\par \pard\plain 
{\comment begin include group__todo.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
To Do List{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v To Do List}
{\xe \v To Do List}
{\comment writeAnchor (group__todo)}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Long Term
\par}
{\tc\tcl2 \v Long Term}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Add debug stubs. One good thing to check for would be that is_picked_systematic doesn't return more elements than requested, and that it has returned the exact number of elements upon destruction. This will call for an extra bool {\i beenCalled}  to prevent errors in temporary instantiations of is_picked_systematic.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Add a module for boost::filter_iterator explanation (e.g. interoperability, constness, etc...).\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Allow passing a RandomNumberGenerator to the constructor of {\b trsl::random_permutation_iterator}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Write an importance_sample_iterator.\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Open Questions
\par}
{\tc\tcl2 \v Open Questions}
\par}
}{\comment endFile}
{\comment end include group__todo.rtf}
\par \pard\plain 
{\comment begin include group__version__history.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version History{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v Version History}
{\xe \v Version History}
{\comment writeAnchor (group__version__history)}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version 0.2.2
\par}
{\tc\tcl2 \v Version 0.2.2}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added TRSL_VERSION_NR.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Renamed trsl::is_picked_systematic::isFirstPick to {\b trsl::is_picked_systematic::is_first_pick}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\b trsl::is_first_pick} to avoid awkward statements like {\f2 i.predicate().is_first_pick(*i)} .\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\f2 index()}  to {\b trsl::reorder_iterator}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\f2 index()}  to {\b trsl::ppfilter_iterator}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Changed "double quotes" include directives to use angle brackets instead.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Removed unnecessary include of {\b trsl/persistent_filter_iterator.hpp} from {\b trsl/is_picked_systematic.hpp}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
For systematic sampling, {\b trsl::ppfilter_iterator} should be used by default, and {\b trsl::persistent_filter_iterator} should be used only when it is guaranteed that the order in which the input population is presented is not following any pattern. To encourage this policy, {\b trsl::persistent_filter_iterator} has been replace by {\b trsl::ppfilter_iterator} in the following examples: examples/trsl_example1.cpp, examples/trsl_example1plus.cpp, examples/ParticleCollection.cpp. Naturally, {\f2 std::list}  had to be replaced with {\f2 std::vector}  in examples/trsl_example1.cpp.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Enhanced documentation.\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version 0.2.1
\par}
{\tc\tcl2 \v Version 0.2.1}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Removed {\f2 const}  on {\f2 predicate_}  in {\b trsl::ppfilter_iterator}, to allow iterator assignment with {\f2 operator=} .\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\f2 isFirstPick()}  to {\b trsl::is_picked_systematic}.\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version 0.2.0
\par}
{\tc\tcl2 \v Version 0.2.0}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Restored default constructor in {\b trsl::random_permutation_iterator} ({\b trsl::random_permutation_iterator} has been renamed {\b trsl::reorder_iterator}, see below).\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pulled {\b trsl::reorder_iterator} out of the old {\b trsl::random_permutation_iterator}. Added {\b trsl::sort_iterator}.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b trsl::random_permutation_iterator} uses a partial shuffle algorithm instead of std::random_shuffle. It is thus efficient to iterate over a permutation of a subset that is much smaller than the population.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Fixed {\f2 operator==}  bug in {\b trsl::persistent_filter_iterator}. Two {\b trsl::persistent_filter_iterator} are now equal if their base iterators are equal {\i and}  if their predicates are equal.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added a default constructor to {\b trsl::is_picked_systematic}. Note that a default-constructed {\b trsl::is_picked_systematic} is invalid.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\b trsl::ppfilter_iterator}.\par}
\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version 0.1.1
\par}
{\tc\tcl2 \v Version 0.1.1}
Changes made to the code are:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
trsl::random_permutation_iterator::random_permutation_iterator(ElementIterator,ElementIterator,index_t) now checks that the permutation size is smaller or equal to the population size, and throws an exception if it is not the case.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b trsl/error_handling.hpp}: TRSL exceptions.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b trsl/common.hpp}: random number wrappers.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b trsl::is_picked_systematic} and {\b trsl::random_permutation_iterator} are now using functions from {\b trsl/common.hpp}. {\b trsl::random_permutation_iterator} was previously using the random generator built in {\f2 std::random_shuffle} , which is usually {\f2 rand} . {\b trsl::is_picked_systematic} was using {\f2 random} . Both will now use {\f2 rand}  by default, and {\f2 random}  if TRSL_USE_BSD_BETTER_RANDOM_GENERATOR is defined. See {\b Random Number Generators}  for more details.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b trsl::is_picked_systematic} is now explicitly handling the case {\f2 sampleSize==0} .\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Removed default constructor in {\b trsl::random_permutation_iterator}.\par}
This release also features many documentation fixes (corrections, rephrasing and additions).\par}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Version 0.1.0
\par}
{\tc\tcl2 \v Version 0.1.0}
Begins with {\b trsl::is_picked_systematic}, {\b trsl::persistent_filter_iterator}, {\b trsl::random_permutation_iterator}. \par}
}{\comment endFile}
{\comment end include group__version__history.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
{\comment begin include namespacetrsl.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl Namespace Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl}
{\xe \v trsl}
{\comment writeAnchor (namespacetrsl)}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b rand_gen}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random number wrapper functions. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b runtime_error}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception for runtime errors in TRSL. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b bad_parameter_value}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thrown when a TRSL component receives a parameter that has a forbidden value. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b is_picked_systematic}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor to use with {\b persistent_filter_iterator} for systematic sampling of a range. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b persistent_filter_iterator}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptation of {\f2 boost::filter_iterator} to allow an element to be selected multiple times. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ppfilter_iterator}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random permutation, persistent filter iterator. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b reorder_iterator}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides an iterator over a permutation of a range. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b weight_accessor}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight accessor that always returns 1. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b mp_weight_accessor}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method Pointer weight accessor. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Iterator > bool {\b is_first_pick} (const Iterator &i){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether {\f2 *i}  has been picked already. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<class Predicate , class Iterator > {\b persistent_filter_iterator}< Predicate, Iterator > {\b make_persistent_filter_iterator} (Predicate f, Iterator x, Iterator end=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<class Predicate , class Iterator > {\b persistent_filter_iterator}< Predicate, Iterator > {\b make_persistent_filter_iterator} (typename boost::iterators::enable_if< boost::is_class< Predicate >, Iterator >::type x, Iterator end=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > {\b reorder_iterator}< ElementIterator > {\b random_permutation_iterator} (ElementIterator first, ElementIterator last, unsigned permutationSize){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random subset of size {\f2 permutationSize}  of a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > {\b reorder_iterator}< ElementIterator > {\b random_permutation_iterator} (ElementIterator first, ElementIterator last){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator , class ElementComparator > {\b reorder_iterator}< ElementIterator > {\b sort_iterator} (ElementIterator first, ElementIterator last, ElementComparator comp, unsigned permutationSize){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through the first {\f2 permutationSize}  elements of a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator , class ElementComparator > {\b reorder_iterator}< ElementIterator > {\b sort_iterator} (ElementIterator first, ElementIterator last, ElementComparator comp){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > {\b reorder_iterator}< ElementIterator > {\b sort_iterator} (ElementIterator first, ElementIterator last){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v is_first_pick\:trsl}
{\xe \v trsl\:is_first_pick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Iterator > bool trsl::is_first_pick ({\comment (startParameterList)}
const Iterator & {\i i}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether {\f2 *i}  has been picked already. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calls {\f2 i.predicate().is_first_pick(*i)} .\par
When sampling from a population, elements with a large weight may be selected several times. This function checks if the element pointed by {\f2 *i}  has been selected already, e.g. at {\f2 *(i-1)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i Iterator} Will typically be trsl::pp_filter_iterator or trsl::persitent_filter_iterator.\par
{\i i} Instance of pp_filter_iterator or persitent_filter_iterator. Should not be the end. \par
}
}{\comment startParagraph}
{
Definition at line 321 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v random_permutation_iterator\:trsl}
{\xe \v trsl\:random_permutation_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator > {\b reorder_iterator}<ElementIterator> trsl::random_permutation_iterator ({\comment (startParameterList)}
ElementIterator {\i first}, {\comment (startParameterList)}
  ElementIterator {\i last}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performing a random permutation requires a series of random integers, these are provided by {\b rand_gen::uniform_int}; see {\b Random Number Generators}  for further details.\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} .\par
Creating such a {\b reorder_iterator} and iterating through it is generally much faster than re-ordering the population itself (or a copy thereof), especially when elements are large, have a complex copy-constructor, or a tall class hierarchy. \par
}{\comment startParagraph}
{
Definition at line 103 of file random_permutation_iterator.hpp.{\comment endParagraph}
}\par
{\comment startParagraph}
{
References random_permutation_iterator().{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v random_permutation_iterator\:trsl}
{\xe \v trsl\:random_permutation_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator > {\b reorder_iterator}<ElementIterator> trsl::random_permutation_iterator ({\comment (startParameterList)}
ElementIterator {\i first}, {\comment (startParameterList)}
  ElementIterator {\i last}, {\comment (startParameterList)}
  unsigned {\i permutationSize}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random subset of size {\f2 permutationSize}  of a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 permutationSize}  should be smaller or equal to the size of the population. If it is not the case, a {\b bad_parameter_value} is thrown.\par
Performing a random permutation requires a series of random integers, these are provided by {\b rand_gen::uniform_int}; see {\b Random Number Generators}  for further details.\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} .\par
Creating such a {\b reorder_iterator} and iterating through it is generally much faster than re-ordering the population itself (or a copy thereof), especially when elements are large, have a complex copy-constructor, or a tall class hierarchy. \par
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\b trsl_example2.cpp}.{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 40 of file random_permutation_iterator.hpp.{\comment endParagraph}
}\par
{\comment startParagraph}
{
References trsl::rand_gen::uniform_int().{\comment endParagraph}
}\par
{\comment startParagraph}
{
Referenced by trsl::ppfilter_iterator< Predicate, ElementIterator >::ppfilter_iterator(), and random_permutation_iterator().{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v sort_iterator\:trsl}
{\xe \v trsl\:sort_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator > {\b reorder_iterator}<ElementIterator> trsl::sort_iterator ({\comment (startParameterList)}
ElementIterator {\i first}, {\comment (startParameterList)}
  ElementIterator {\i last}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The population is sorted using {\f2 std::less<>()} , i.e. in ascending order.\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} .\par
Creating such a {\b reorder_iterator} and iterating through it is generally much faster than re-ordering the population itself (or a copy thereof), especially when elements are large, have a complex copy-constructor, or a tall class hierarchy. \par
}{\comment startParagraph}
{
Definition at line 180 of file sort_iterator.hpp.{\comment endParagraph}
}\par
{\comment startParagraph}
{
References sort_iterator().{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v sort_iterator\:trsl}
{\xe \v trsl\:sort_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator , class ElementComparator > {\b reorder_iterator}<ElementIterator> trsl::sort_iterator ({\comment (startParameterList)}
ElementIterator {\i first}, {\comment (startParameterList)}
  ElementIterator {\i last}, {\comment (startParameterList)}
  ElementComparator {\i comp}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A comparator is provided through {\f2 comp} . {\f2 Comparator}  has to model {\f2 Strict Weak Ordering}. In particular {\f2 {\f2 std::less<ElementType>()} } and {\f2 {\f2 std::greater<ElementType>()} } can work, whereas {\f2 {\f2 std::less_equal<ElementType>()} } and {\f2 {\f2 std::greater_equal<ElementType>()} } will {\i not} .\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} .\par
Creating such a {\b reorder_iterator} and iterating through it is generally much faster than re-ordering the population itself (or a copy thereof), especially when elements are large, have a complex copy-constructor, or a tall class hierarchy. \par
}{\comment startParagraph}
{
Definition at line 153 of file sort_iterator.hpp.{\comment endParagraph}
}\par
{\comment startParagraph}
{
References sort_iterator().{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v sort_iterator\:trsl}
{\xe \v trsl\:sort_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator , class ElementComparator > {\b reorder_iterator}<ElementIterator> trsl::sort_iterator ({\comment (startParameterList)}
ElementIterator {\i first}, {\comment (startParameterList)}
  ElementIterator {\i last}, {\comment (startParameterList)}
  ElementComparator {\i comp}, {\comment (startParameterList)}
  unsigned {\i permutationSize}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through the first {\f2 permutationSize}  elements of a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\f2 permutationSize}  should be smaller or equal to the size of the population. If it is not the case, a {\b bad_parameter_value} is thrown.\par
A comparator is provided through {\f2 comp} . {\f2 Comparator}  has to model {\f2 Strict Weak Ordering}. In particular {\f2 {\f2 std::less<ElementType>()} } and {\f2 {\f2 std::greater<ElementType>()} } will work, whereas {\f2 {\f2 std::less_equal<ElementType>()} } and {\f2 {\f2 std::greater_equal<ElementType>()} } will {\i not} .\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} .\par
Creating such a {\b reorder_iterator} and iterating through it is generally much faster than re-ordering the population itself (or a copy thereof), especially when elements are large, have a complex copy-constructor, or a tall class hierarchy. \par
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\b trsl_example2.cpp}.{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 76 of file sort_iterator.hpp.{\comment endParagraph}
}\par
{\comment startParagraph}
{
Referenced by sort_iterator().{\comment endParagraph}
}\par
}
{\comment endFile}
{\comment end include namespacetrsl.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include namespacetrsl_1_1detail.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail Namespace Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail}
{\xe \v trsl::detail}
{\comment writeAnchor (namespacetrsl_1_1detail)}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b identity}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b persistent_filter_iterator_base}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ppfilter_iterator_base}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reorder_iterator_base}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b at_index_comp}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename RandomAccessIterator , typename RandomNumberGenerator > void {\b partial_random_shuffle} (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, RandomNumberGenerator &rg){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include namespacetrsl_1_1detail.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include namespacetrsl_1_1rand__gen.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::rand_gen Namespace Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::rand_gen}
{\xe \v trsl::rand_gen}
{\comment writeAnchor (namespacetrsl_1_1rand__gen)}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random number wrapper functions. }{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b uniform_int} (unsigned int n){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an integer in {\f2 [0,n[} . Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Real > Real {\b uniform_01} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a float in {\f2 [0,1[} . Used internally. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random number wrapper functions. \par
}{\comment endTextBlock}
}
{\comment endFile}
{\comment end include namespacetrsl_1_1rand__gen.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
{\comment begin include classtrsl_1_1detail_1_1at__index__comp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail::at_index_comp< RandomIterator, Comparator > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail::at_index_comp}
{\xe \v trsl::detail::at_index_comp}
{\comment writeAnchor (classtrsl_1_1detail_1_1at__index__comp)}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b at_index_comp} (const RandomIterator &first, const Comparator &comp){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

bool {\b operator()} (unsigned i, unsigned j){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

RandomIterator {\b elements_}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Comparator {\b comp_}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class RandomIterator, class Comparator> class trsl::detail::at_index_comp< RandomIterator, Comparator >{\comment (newParagraph)}
\par
}

{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 25 of file sort_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b sort_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1detail_1_1at__index__comp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1bad__parameter__value.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::bad_parameter_value Class Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::bad_parameter_value}
{\xe \v trsl::bad_parameter_value}
{\comment writeAnchor (classtrsl_1_1bad__parameter__value)}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thrown when a TRSL component receives a parameter that has a forbidden value. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <error_handling.hpp>}{\comment endParagraph}
}\par
{\comment startClassDiagram }
Inheritance diagram for trsl::bad_parameter_value:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtrsl_1_1bad__parameter__value.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b bad_parameter_value} (const std::string &s){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thrown when a TRSL component receives a parameter that has a forbidden value. \par
}{\comment startParagraph}
{
Definition at line 26 of file error_handling.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b error_handling.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1bad__parameter__value.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1detail_1_1identity.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail::identity< T > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail::identity}
{\xe \v trsl::detail::identity}
{\comment writeAnchor (classtrsl_1_1detail_1_1identity)}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

T {\b operator()} (const T &t){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T> class trsl::detail::identity< T >{\comment (newParagraph)}
\par
}

{\comment startParagraph}
{\comment (newParagraph)}
\par
{
Definition at line 35 of file common.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b common.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1detail_1_1identity.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1is__picked__systematic.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::is_picked_systematic< ElementType, WeightType, WeightAccessor > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic}
{\comment writeAnchor (classtrsl_1_1is__picked__systematic)}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor to use with {\b persistent_filter_iterator} for systematic sampling of a range. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <is_picked_systematic.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef ElementType {\b element_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef WeightType {\b weight_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef WeightAccessor {\b weight_accessor_type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b is_picked_systematic} (){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, shoud not be used explicitely. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b is_picked_systematic} (size_t sampleSize, WeightType populationWeight, WeightAccessor const &wac=WeightAccessor()){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construction with system-provided random number. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b is_picked_systematic} (size_t sampleSize, WeightType populationWeight, WeightType uniform01, WeightAccessor const &wac=WeightAccessor()){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construction with user-provided random number. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (const ElementType &e){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decides whether {\f2 e}  should be picked or not (used by {\b persistent_filter_iterator}). }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_first_pick} (const ElementType &e) const {\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether {\f2 e}  has been picked already. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b is_picked_systematic}< ElementType, WeightType, WeightAccessor > &p) const {\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether two predicates are at the same sampling advancement. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> class trsl::is_picked_systematic< ElementType, WeightType, WeightAccessor >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor to use with {\b persistent_filter_iterator} for systematic sampling of a range. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The sampling method is systematic sampling [1, 2].\par
This class is intended to be used as a predicate functor to {\b trsl::persistent_filter_iterator} to form a {\i sample iterator} . The sample iterator accesses a population of elements through a range defined by a pair of Forward Iterators (begin/end), and provides on-the-fly iteration through a sample of the population.\par
Systematic sampling may perform very badly if the order in which the input population is presented is following a pattern. If a pattern is likely to occur in the population, the user may want to pipe the sample iterator {\i after}  a {\b trsl::random_permutation_iterator}, or use {\b is_picked_systematic} with {\b ppfilter_iterator}. The resulting iterator effectively implements {\i probability sampling} . The price to pay for probability sampling is a {\i Random Access Iterator} . While {\b persistent_filter_iterator} will work e.g. with {\f2 std::list} , {\b ppfilter_iterator} requires e.g. {\f2 std::vector}  or {\f2 std::deque} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\i ElementType} Type of the elements in the population. Constness and reference modifiers are handled internally; this parameter should be a bare type, e.g. {\f2 Particle}  ({\i not}  {\f2 const Particle&} ).\par
{\i WeightType} Element weight type, should be a floating point type. Defaults to {\f2 double} .\par
{\i WeightAccessor} Type of the accessor that will allow to extract weights from elements. Defaults to {\b mp_weight_accessor}, see {\b Accessors}  for further details on accessors.\par
}
{\b References:} \par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[1] R. Douc, O. Cappe, and E. Moulines. Comparison of resampling schemes for particle filtering. International Symposium on Parallel and Distributed Processing and Applications, 2005:64, 2005.\par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
[2] J. Hol, T. Schn, and F. Gustafsson. On resampling algorithms for particle filters. In Nonlinear Statistical Signal Processing Workshop, 2006. \par}
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\b ParticleCollection.hpp}, {\b trsl_example1.cpp}, and {\b trsl_example2.cpp}.{\comment endParagraph}
}\par
{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 77 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v is_picked_systematic\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:is_picked_systematic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::{\b is_picked_systematic} (){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default constructor, shoud not be used explicitely. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor makes an invalid predicate. It should only be used in cases where the predicate is never used. \par
}{\comment startParagraph}
{
Definition at line 92 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v is_picked_systematic\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:is_picked_systematic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::{\b is_picked_systematic} ({\comment (startParameterList)}
size_t {\i sampleSize}, {\comment (startParameterList)}
  WeightType {\i populationWeight}, {\comment (startParameterList)}
  WeightAccessor const & {\i wac} = {\f2 WeightAccessor()}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construction with system-provided random number. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The systematic sampling predicate initialization needs a random number in {\f2 [0,1[} . This constructor uses {\b trsl::rand_gen::uniform_01} to generate that number. See {\b Random Number Generators}  for more details.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i sampleSize} Number of elements in the sample, within {\f2 [0, infinity[} .\par
{\i populationWeight} Total weight of the population, within {\f2 ]0, infinity[} . Generally equal to 1.\par
{\i wac} Weight accessor. Defaults to {\b mp_weight_accessor}. Note that if you don't pass explicitly a {\b mp_weight_accessor}({\f2 &ElementType::GETWEIGHTMETHOD} ), the default constructor for {\b mp_weight_accessor} will setup to always return 1, ignoring element weights. See {\b Accessors}  for further details.\par
}
The population weight has to be strictly larger than 0. Also, {\f2 WeightType}  should be fine enough to allow the sum of all element weights to be close to {\f2 populationWeight} . \par
}{\comment startParagraph}
{
Definition at line 124 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v is_picked_systematic\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:is_picked_systematic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::{\b is_picked_systematic} ({\comment (startParameterList)}
size_t {\i sampleSize}, {\comment (startParameterList)}
  WeightType {\i populationWeight}, {\comment (startParameterList)}
  WeightType {\i uniform01}, {\comment (startParameterList)}
  WeightAccessor const & {\i wac} = {\f2 WeightAccessor()}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construction with user-provided random number. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The systematic sampling predicate initialization needs a random number in {\f2 [0,1[} . This constructor allows the user to provide that number directly; the user is free to choose a fancy random number generator, such as the {\f2 Boost Random Number Library} or {\f2 GSL}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i sampleSize} Number of elements in the sample, within {\f2 [0, infinity[} .\par
{\i populationWeight} Total weight of the population, within {\f2 ]0, infinity[} . Generally equal to 1.\par
{\i uniform01} Random number in {\f2 [0,1[} .\par
{\i wac} Weight accessor. Defaults to {\b mp_weight_accessor}. Note that if you don't pass explicitly a {\b mp_weight_accessor}({\f2 &ElementType::GETWEIGHTMETHOD} ), the default constructor for {\b mp_weight_accessor} will setup to always return 1, ignoring element weights. See {\b Accessors}  for further details.\par
}
The population weight has to be strictly larger than 0. Also, {\f2 WeightType}  should be fine enough to allow the sum of all element weights to be close to {\f2 populationWeight} . \par
}{\comment startParagraph}
{
Definition at line 164 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v is_first_pick\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:is_first_pick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> bool {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::is_first_pick ({\comment (startParameterList)}
const ElementType & {\i e}) const{\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether {\f2 e}  has been picked already. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method will return a coherent value only if the last call of {\b operator()(const ElementType&)} was on {\f2 e}  and returned true. When {\b is_picked_systematic} is used with a presistent_filter_iterator {\f2 i} , this assumption is always valid for {\f2 *i}  as long as {\f2 i}  is not the end.\par
This method is awkward to use directly; it is meant to be called by {\b trsl::is_first_pick}. \par
}{\comment startParagraph}
{
Definition at line 226 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v operator()\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> bool {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::operator() ({\comment (startParameterList)}
const ElementType & {\i e}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decides whether {\f2 e}  should be picked or not (used by {\b persistent_filter_iterator}). }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Part of the requirements for {\b persistent_filter_iterator} predicates. \par
}{\comment startParagraph}
{
Definition at line 181 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v operator==\:trsl::is_picked_systematic}
{\xe \v trsl::is_picked_systematic\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ElementType, typename WeightType = double, typename WeightAccessor = mp_weight_accessor<WeightType, ElementType>> bool {\b trsl::is_picked_systematic}< ElementType, WeightType, WeightAccessor >::operator== ({\comment (startParameterList)}
const {\b is_picked_systematic}< ElementType, WeightType, WeightAccessor > & {\i p}) const{\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns whether two predicates are at the same sampling advancement. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Part of the requirements for {\b persistent_filter_iterator} predicates. \par
}{\comment startParagraph}
{
Definition at line 243 of file is_picked_systematic.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b is_picked_systematic.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1is__picked__systematic.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1mp__weight__accessor.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::mp_weight_accessor< WeightType, ElementType > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::mp_weight_accessor}
{\xe \v trsl::mp_weight_accessor}
{\comment writeAnchor (classtrsl_1_1mp__weight__accessor)}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method Pointer weight accessor. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <weight_accessor.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef WeightType(ElementType::* {\b WeightAccessorMethodPointer} )() const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer to a const method of ElementType that returns double. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b mp_weight_accessor} ({\b WeightAccessorMethodPointer} wptr=NULL){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor from a WeightAccessorMethodPointer. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WeightType {\b operator()} (ElementType const &e) const {\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor implementation. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename WeightType, typename ElementType> class trsl::mp_weight_accessor< WeightType, ElementType >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method Pointer weight accessor. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight accessor for element classes that provide access to their weight through a method signed {\f2 WeightType (ElementType::*)() const} .\par
This class is very similar to {\f2 std::const_mem_fun_ref_t} . The only two differences are {
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b mp_weight_accessor} provides a default constructor that initializes the method pointer to NULL; \par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b mp_weight_accessor} checks if the method pointer is NULL before dereferencing it.\par}
These differences allow {\b mp_weight_accessor} to be used as a default type for {\b is_picked_systematic} weight accessor, since a default-value initialization won't imply segfault. However, access is a bit slower because of the extra check for a non-NULL pointer. If the pointer is NULL, {\f2 operator()}  returns 1.\par
See {\b Accessors}  for more details. \par
}{\comment startParagraph}
{
Definition at line 61 of file weight_accessor.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v mp_weight_accessor\:trsl::mp_weight_accessor}
{\xe \v trsl::mp_weight_accessor\:mp_weight_accessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename WeightType , typename ElementType > {\b trsl::mp_weight_accessor}< WeightType, ElementType >::{\b mp_weight_accessor} ({\comment (startParameterList)}
{\b WeightAccessorMethodPointer} {\i wptr} = {\f2 NULL}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor from a WeightAccessorMethodPointer. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\i wptr} Pointer to the method of ElementType that returns the element weight. If no pointer is passed, operator() will return 1 all the time. \par
}
}{\comment startParagraph}
{
Definition at line 75 of file weight_accessor.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v operator()\:trsl::mp_weight_accessor}
{\xe \v trsl::mp_weight_accessor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename WeightType , typename ElementType > WeightType {\b trsl::mp_weight_accessor}< WeightType, ElementType >::operator() ({\comment (startParameterList)}
ElementType const & {\i e}) const{\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor implementation. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 1 if wptr_ is NULL, {\f2 e.*wptr_()}  else. \par
}}{\comment startParagraph}
{
Definition at line 83 of file weight_accessor.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b weight_accessor.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1mp__weight__accessor.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1persistent__filter__iterator.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::persistent_filter_iterator< Predicate, Iterator > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::persistent_filter_iterator}
{\xe \v trsl::persistent_filter_iterator}
{\comment writeAnchor (classtrsl_1_1persistent__filter__iterator)}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptation of {\f2 boost::filter_iterator} to allow an element to be selected multiple times. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <persistent_filter_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b persistent_filter_iterator} (Predicate f, Iterator x, Iterator end_=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b persistent_filter_iterator} (Iterator x, Iterator end_=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<class OtherIterator > {\b persistent_filter_iterator} ({\b persistent_filter_iterator}< Predicate, OtherIterator > const &t, typename boost::enable_if_convertible< OtherIterator, Iterator >::type *=0){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Predicate {\b predicate} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Iterator {\b end} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

class {\b boost::iterator_core_access}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Predicate, class Iterator> class trsl::persistent_filter_iterator< Predicate, Iterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptation of {\f2 boost::filter_iterator} to allow an element to be selected multiple times. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The class {\f2 boost::filter_iterator} is an example of {\f2 boost::iterator_adaptor} that allows iterating through a range, skipping elements that don't verify a predicate. In {\f2 boost::filter_iterator}, incrementing the iterator will {\i always}  advance of at least one element. In {\b persistent_filter_iterator}, an incrementation will not advance to a next element until the predicate becomes false on the current element. This implies that the predicate has either some memory, or a pseudo-random behavior.\par
A {\b persistent_filter_iterator} thus iterates over a {\i virtual}  range. Consequently, equality of two {\b persistent_filter_iterator} is only verified if they point to the same element in the original range {\i and}  if their predicates are equal. Predicates must thus implement {\f2 operator==} . To see whether two different {\b persistent_filter_iterator} actually point to the same input range element, one can compare the underlying iterators available through the {\f2 base()}  method.\par
The doc on {\f2 boost::filter_iterator} applies for this class, except for the small differences noted above. \par
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\b trsl_example2.cpp}.{\comment endParagraph}
}\par
{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 93 of file persistent_filter_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b persistent_filter_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1persistent__filter__iterator.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structtrsl_1_1detail_1_1persistent__filter__iterator__base.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail::persistent_filter_iterator_base< Predicate, Iterator > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail::persistent_filter_iterator_base}
{\xe \v trsl::detail::persistent_filter_iterator_base}
{\comment writeAnchor (structtrsl_1_1detail_1_1persistent__filter__iterator__base)}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <persistent_filter_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::iterator_adaptor< {\b persistent_filter_iterator}< Predicate, Iterator >, Iterator, boost::use_default, typename boost::mpl::if_< boost::is_convertible< typename boost::iterator_traversal< Iterator >::type, boost::random_access_traversal_tag >, boost::forward_traversal_tag, boost::forward_traversal_tag >::type > {\b type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Predicate, class Iterator> struct trsl::detail::persistent_filter_iterator_base< Predicate, Iterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. \par
}{\comment startParagraph}
{
Definition at line 36 of file persistent_filter_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b persistent_filter_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structtrsl_1_1detail_1_1persistent__filter__iterator__base.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1ppfilter__iterator.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::ppfilter_iterator< Predicate, ElementIterator > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::ppfilter_iterator}
{\xe \v trsl::ppfilter_iterator}
{\comment writeAnchor (classtrsl_1_1ppfilter__iterator)}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random permutation, persistent filter iterator. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <ppfilter_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::element_iterator {\b element_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b ppfilter_iterator} (Predicate f, ElementIterator first, ElementIterator last){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class OtherElementIterator > {\b ppfilter_iterator} ({\b ppfilter_iterator}< Predicate, OtherElementIterator > const &r, typename boost::enable_if_convertible< OtherElementIterator, ElementIterator >::type *=0){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows conversion from a {\b ppfilter_iterator} to a const {\b ppfilter_iterator}, won't allow conversion from a const {\b ppfilter_iterator} to a {\b ppfilter_iterator}. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b ppfilter_iterator}< Predicate, ElementIterator > {\b begin} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b ppfilter_iterator} pointing to the begining of the range. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b ppfilter_iterator}< Predicate, ElementIterator > {\b end} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b ppfilter_iterator} pointing to the end of the range. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

upstream_iterator::index_t {\b index} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the element that the iterator is currently pointing to. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

Predicate {\b predicate} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b persistent_filter_iterator} predicate. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

class {\b boost::iterator_core_access}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

class {\b ppfilter_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Predicate, class ElementIterator> class trsl::ppfilter_iterator< Predicate, ElementIterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random permutation, persistent filter iterator. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class pipes a {\b random_permutation_iterator()} (upstream) with a {\b persistent_filter_iterator} (downstream). It is intended to be used with {\b is_picked_systematic}. Systematic sampling of a random permutation achieves {\i probability sampling} .\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} . \par
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\b ParticleCollection.hpp}, {\b trsl_example1.cpp}, and {\b trsl_example2.cpp}.{\comment endParagraph}
}\par
{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 58 of file ppfilter_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v ppfilter_iterator\:trsl::ppfilter_iterator}
{\xe \v trsl::ppfilter_iterator\:ppfilter_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Predicate, class ElementIterator> template<class OtherElementIterator > {\b trsl::ppfilter_iterator}< Predicate, ElementIterator >::{\b ppfilter_iterator} ({\comment (startParameterList)}
{\b ppfilter_iterator}< Predicate, OtherElementIterator > const & {\i r}, {\comment (startParameterList)}
  typename boost::enable_if_convertible< OtherElementIterator, ElementIterator >::type * = {\f2 0}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows conversion from a {\b ppfilter_iterator} to a const {\b ppfilter_iterator}, won't allow conversion from a const {\b ppfilter_iterator} to a {\b ppfilter_iterator}. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By "const {\b ppfilter_iterator}", we mean that the {\f2 ElementIterator}  is const, e.g. {\f2 std::vector<Particle>::const_iterator} . \par
}{\comment startParagraph}
{
Definition at line 99 of file ppfilter_iterator.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ppfilter_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1ppfilter__iterator.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structtrsl_1_1detail_1_1ppfilter__iterator__base.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail::ppfilter_iterator_base< Predicate, ElementIterator > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail::ppfilter_iterator_base}
{\xe \v trsl::detail::ppfilter_iterator_base}
{\comment writeAnchor (structtrsl_1_1detail_1_1ppfilter__iterator__base)}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <ppfilter_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef Predicate {\b predicate_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef ElementIterator {\b element_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b reorder_iterator}< ElementIterator > {\b upstream_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef {\b persistent_filter_iterator}< Predicate, {\b upstream_iterator} > {\b downstream_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::iterator_adaptor< {\b ppfilter_iterator}< Predicate, ElementIterator >, {\b downstream_iterator}, typename boost::detail::iterator_traits< ElementIterator >::value_type, boost::forward_traversal_tag, typename boost::detail::iterator_traits< ElementIterator >::reference > {\b type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Predicate, class ElementIterator> struct trsl::detail::ppfilter_iterator_base< Predicate, ElementIterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. \par
}{\comment startParagraph}
{
Definition at line 27 of file ppfilter_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ppfilter_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structtrsl_1_1detail_1_1ppfilter__iterator__base.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1reorder__iterator.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::reorder_iterator< ElementIterator > Class Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::reorder_iterator}
{\xe \v trsl::reorder_iterator}
{\comment writeAnchor (classtrsl_1_1reorder__iterator)}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides an iterator over a permutation of a range. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <reorder_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::index_t {\b index_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::index_container {\b index_container}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::index_container_ptr {\b index_container_ptr}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::index_iterator {\b index_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef base_t::element_iterator {\b element_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reorder_iterator} (ElementIterator first, const index_container_ptr &index_collection){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an iterator that will walk through the elements of the range that begins at {\f2 first} , follwing the order defined by {\f2 index_collection} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class OtherElementIterator > {\b reorder_iterator} ({\b reorder_iterator}< OtherElementIterator > const &r, typename boost::enable_if_convertible< OtherElementIterator, ElementIterator >::type *=0){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows conversion from a {\b reorder_iterator} to a const {\b reorder_iterator}, won't allow conversion from a const {\b reorder_iterator} to a {\b reorder_iterator}. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reorder_iterator}< ElementIterator > {\b begin} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b reorder_iterator} pointing to the begining of the permutation. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b reorder_iterator}< ElementIterator > {\b end} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b reorder_iterator} pointing to the end of the permutation. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

index_t {\b index} () const {\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the index of the element that the iterator is currently pointing to. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

index_container_ptr {\b m_index_collection}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

class {\b boost::iterator_core_access}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

class {\b reorder_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class ElementIterator> class trsl::reorder_iterator< ElementIterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides an iterator over a permutation of a range. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is a fork of {\f2 boost::permutation_iterator}. With {\f2 boost::permutation_iterator}, the user provides a population, and a range of index that defines a permutation over the population. It allows for much flexibility, but leaves the user responsible for storing an array of index. This class allows to store the array internally, in the same way as {\f2 boost::shared_container_iterator}.\par
The index array is stored within the iterator, by means of a {\f2 boost::shared_ptr}; thus, all copies of a reorder iterator share the same index array. One drawback is that {\b reorder_iterator} copy is somewhat slower than ElementIterator copy. Incrementation is still plainly efficient, nevertheless.\par
When iterating over a permutation of a population range using an index range, the iteration is actually performed over the index range; the population range is only used when dereferencing. Thus, every {\b trsl::reorder_iterator} knows where it begins and where it ends, hence provided {\b begin()} and {\b end()} methods.\par
TRSL provides several functions that generate reoder iterators for common reorderings. See {\b random_permutation_iterator()} and {\b sort_iterator()}.\par
{\f2 ElementIterator}  should model {\i Random Access Iterator} . See the doc on {\f2 boost::permutation_iterator} for further details. \par
}{\comment (startSimpleSect)}
{{{\b Examples: }}{\comment (newParagraph)}
\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\comment (startDescForItem) }
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\b trsl_example2.cpp}.{\comment endParagraph}
}\par
{\comment (endDescForItem) }
{\comment (endSimpleSect)}
}{\comment startParagraph}
{
Definition at line 94 of file reorder_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v reorder_iterator\:trsl::reorder_iterator}
{\xe \v trsl::reorder_iterator\:reorder_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class ElementIterator> template<class OtherElementIterator > {\b trsl::reorder_iterator}< ElementIterator >::{\b reorder_iterator} ({\comment (startParameterList)}
{\b reorder_iterator}< OtherElementIterator > const & {\i r}, {\comment (startParameterList)}
  typename boost::enable_if_convertible< OtherElementIterator, ElementIterator >::type * = {\f2 0}){\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allows conversion from a {\b reorder_iterator} to a const {\b reorder_iterator}, won't allow conversion from a const {\b reorder_iterator} to a {\b reorder_iterator}. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
By "const {\b reorder_iterator}", we mean that the {\f2 ElementIterator}  is const, e.g. {\f2 std::vector<Particle>::const_iterator} . \par
}{\comment startParagraph}
{
Definition at line 141 of file reorder_iterator.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b reorder_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1reorder__iterator.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structtrsl_1_1detail_1_1reorder__iterator__base.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::detail::reorder_iterator_base< ElementIterator > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::detail::reorder_iterator_base}
{\xe \v trsl::detail::reorder_iterator_base}
{\comment writeAnchor (structtrsl_1_1detail_1_1reorder__iterator__base)}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <reorder_iterator.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef ElementIterator {\b element_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef size_t {\b index_t}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef std::vector< index_t > {\b index_container}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::shared_ptr< index_container > {\b index_container_ptr}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef index_container::const_iterator {\b index_iterator}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

typedef boost::iterator_adaptor< {\b reorder_iterator}< ElementIterator >, index_iterator, typename boost::detail::iterator_traits< ElementIterator >::value_type, boost::use_default, typename boost::detail::iterator_traits< ElementIterator >::reference > {\b type}{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class ElementIterator> struct trsl::detail::reorder_iterator_base< ElementIterator >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. \par
}{\comment startParagraph}
{
Definition at line 36 of file reorder_iterator.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b reorder_iterator.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structtrsl_1_1detail_1_1reorder__iterator__base.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include classtrsl_1_1runtime__error.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::runtime_error Class Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::runtime_error}
{\xe \v trsl::runtime_error}
{\comment writeAnchor (classtrsl_1_1runtime__error)}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception for runtime errors in TRSL. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <error_handling.hpp>}{\comment endParagraph}
}\par
{\comment startClassDiagram }
Inheritance diagram for trsl::runtime_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classtrsl_1_1runtime__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

{\b runtime_error} (const std::string &s){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception for runtime errors in TRSL. \par
}{\comment startParagraph}
{
Definition at line 16 of file error_handling.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b error_handling.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include classtrsl_1_1runtime__error.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include structtrsl_1_1weight__accessor.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl::weight_accessor< WeightType, ElementType > Struct Template Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v trsl::weight_accessor}
{\xe \v trsl::weight_accessor}
{\comment writeAnchor (structtrsl_1_1weight__accessor)}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight accessor that always returns 1. }{\comment endParagraph}
}\par
{\comment startParagraph}
{
{\f2 #include <weight_accessor.hpp>}{\comment endParagraph}
}\par
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
WeightType {\b operator()} (ElementType const &e) const {\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor implementation. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\comment Begin SubSubSection}
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename WeightType, typename ElementType> struct trsl::weight_accessor< WeightType, ElementType >{\comment (newParagraph)}
\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight accessor that always returns 1. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This accessor can be passed to sample from a population of equal-weight elements. The total weight of the population should naturally be set to the number of elements in the population. This accessor is of type {\i functor} , see {\b Accessors}  for more details. \par
}{\comment startParagraph}
{
Definition at line 23 of file weight_accessor.hpp.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v operator()\:trsl::weight_accessor}
{\xe \v trsl::weight_accessor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename WeightType , typename ElementType > WeightType {\b trsl::weight_accessor}< WeightType, ElementType >::operator() ({\comment (startParameterList)}
ElementType const & {\i e}) const{\f2  [inline]}{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor implementation. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 1. \par
}}{\comment startParagraph}
{
Definition at line 30 of file weight_accessor.hpp.{\comment endParagraph}
}\par
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\comment (startItemList level=0) }
{{\comment (startItemListItem)}
{\comment (newParagraph)}
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b weight_accessor.hpp}{\comment (endItemListItem)}
{\comment (newParagraph)}
\par
{\comment (endItemList level=1)}
}{\comment endFile}
{\comment end include structtrsl_1_1weight__accessor.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
{\comment begin include common_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
common.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v common.hpp}
{\xe \v common.hpp}
{\comment writeAnchor (common_8hpp)}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdlib>}{\comment (lineBreak)}
\par
{\f2 #include <algorithm>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::detail::identity< T >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::rand_gen}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random number wrapper functions. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TRSL_VERSION}\~ "0.2.2"{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code version string. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TRSL_VERSION_NR}\~ 100020200{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code version number. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename RandomAccessIterator , typename RandomNumberGenerator > void {\b trsl::detail::partial_random_shuffle} (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, RandomNumberGenerator &rg){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

unsigned int {\b trsl::rand_gen::uniform_int} (unsigned int n){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an integer in {\f2 [0,n[} . Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<typename Real > Real {\b trsl::rand_gen::uniform_01} (){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a float in {\f2 [0,1[} . Used internally. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b common.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation{\comment endGroupHeader}
\par
\pard\plain 
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v TRSL_VERSION\:common.hpp}
{\xe \v common.hpp\:TRSL_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TRSL_VERSION\~ "0.2.2"{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code version string. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defined as {\i major} .{\i minor} .{\i bugfix} . \par
}{\comment startParagraph}
{
Definition at line 19 of file common.hpp.{\comment endParagraph}
}\par
}
{\comment startDoxyAnchor}
{\comment startMemberDoc}
{\xe \v TRSL_VERSION_NR\:common.hpp}
{\xe \v common.hpp\:TRSL_VERSION_NR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TRSL_VERSION_NR\~ 100020200{\comment endMemberDoc}
}
}{\comment (newParagraph)}
\par
{\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{\comment (startIndent) }
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code version number. }{\comment endParagraph}
}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defined as 1{\i MMmmbbii} , where {\i MM}  is the major release number, {\i mm}  is the minor release number, {\i bb}  is the bug-fix release number, and {\i ii}  is the internal release number. \par
}{\comment startParagraph}
{
Definition at line 27 of file common.hpp.{\comment endParagraph}
}\par
}
{\comment endFile}
{\comment end include common_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include error__handling_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
error_handling.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v error_handling.hpp}
{\xe \v error_handling.hpp}
{\comment writeAnchor (error__handling_8hpp)}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdexcept>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::runtime_error}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception for runtime errors in TRSL. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::bad_parameter_value}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Thrown when a TRSL component receives a parameter that has a forbidden value. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b error_handling.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include error__handling_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include is__picked__systematic_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
is_picked_systematic.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v is_picked_systematic.hpp}
{\xe \v is_picked_systematic.hpp}
{\comment writeAnchor (is__picked__systematic_8hpp)}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <trsl/common.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/weight_accessor.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <algorithm>}{\comment (lineBreak)}
\par
{\f2 #include <functional>}{\comment (lineBreak)}
\par
{\f2 #include <utility>}{\comment (lineBreak)}
\par
{\f2 #include <cstdlib>}{\comment (lineBreak)}
\par
{\f2 #include <limits>}{\comment (lineBreak)}
\par
{\f2 #include <cassert>}{\comment (lineBreak)}
\par
{\f2 #include <boost/static_assert.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::is_picked_systematic< ElementType, WeightType, WeightAccessor >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functor to use with {\b persistent_filter_iterator} for systematic sampling of a range. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Iterator > bool {\b trsl::is_first_pick} (const Iterator &i){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return whether {\f2 *i}  has been picked already. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b is_picked_systematic.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include is__picked__systematic_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include persistent__filter__iterator_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
persistent_filter_iterator.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v persistent_filter_iterator.hpp}
{\xe \v persistent_filter_iterator.hpp}
{\comment writeAnchor (persistent__filter__iterator_8hpp)}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <boost/iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/iterator/iterator_adaptor.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/iterator/iterator_categories.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/type_traits/is_class.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/static_assert.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b trsl::detail::persistent_filter_iterator_base< Predicate, Iterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::persistent_filter_iterator< Predicate, Iterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adaptation of {\f2 boost::filter_iterator} to allow an element to be selected multiple times. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<class Predicate , class Iterator > persistent_filter_iterator< Predicate, Iterator > {\b trsl::make_persistent_filter_iterator} (Predicate f, Iterator x, Iterator end=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\comment startDoxyAnchor}

template<class Predicate , class Iterator > persistent_filter_iterator< Predicate, Iterator > {\b trsl::make_persistent_filter_iterator} (typename boost::iterators::enable_if< boost::is_class< Predicate >, Iterator >::type x, Iterator end=Iterator()){\comment endDoxyAnchor}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b persistent_filter_iterator.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include persistent__filter__iterator_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include ppfilter__iterator_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ppfilter_iterator.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v ppfilter_iterator.hpp}
{\xe \v ppfilter_iterator.hpp}
{\comment writeAnchor (ppfilter__iterator_8hpp)}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <trsl/error_handling.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/common.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/reorder_iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/random_permutation_iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/persistent_filter_iterator.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b trsl::detail::ppfilter_iterator_base< Predicate, ElementIterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::ppfilter_iterator< Predicate, ElementIterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Random permutation, persistent filter iterator. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b ppfilter_iterator.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include ppfilter__iterator_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include random__permutation__iterator_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
random_permutation_iterator.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v random_permutation_iterator.hpp}
{\xe \v random_permutation_iterator.hpp}
{\comment writeAnchor (random__permutation__iterator_8hpp)}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <trsl/reorder_iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/common.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/error_handling.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > reorder_iterator< ElementIterator > {\b trsl::random_permutation_iterator} (ElementIterator first, ElementIterator last, unsigned permutationSize){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random subset of size {\f2 permutationSize}  of a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > reorder_iterator< ElementIterator > {\b trsl::random_permutation_iterator} (ElementIterator first, ElementIterator last){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a random permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b random_permutation_iterator.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include random__permutation__iterator_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include reorder__iterator_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
reorder_iterator.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v reorder_iterator.hpp}
{\xe \v reorder_iterator.hpp}
{\comment writeAnchor (reorder__iterator_8hpp)}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <trsl/error_handling.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/common.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <iterator>}{\comment (lineBreak)}
\par
{\f2 #include <vector>}{\comment (lineBreak)}
\par
{\f2 #include <algorithm>}{\comment (lineBreak)}
\par
{\f2 #include <boost/iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/iterator/iterator_categories.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/iterator/iterator_adaptor.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <boost/shared_ptr.hpp>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b trsl::detail::reorder_iterator_base< ElementIterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::reorder_iterator< ElementIterator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides an iterator over a permutation of a range. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b reorder_iterator.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include reorder__iterator_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include sort__iterator_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
sort_iterator.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v sort_iterator.hpp}
{\xe \v sort_iterator.hpp}
{\comment writeAnchor (sort__iterator_8hpp)}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{\comment startTextBlock}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <trsl/reorder_iterator.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/common.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <trsl/error_handling.hpp>}{\comment (lineBreak)}
\par
{\f2 #include <functional>}{\comment (lineBreak)}
\par
{\comment endTextBlock}
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::detail::at_index_comp< RandomIterator, Comparator >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl::detail}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implementation details. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator , class ElementComparator > reorder_iterator< ElementIterator > {\b trsl::sort_iterator} (ElementIterator first, ElementIterator last, ElementComparator comp, unsigned permutationSize){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through the first {\f2 permutationSize}  elements of a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator , class ElementComparator > reorder_iterator< ElementIterator > {\b trsl::sort_iterator} (ElementIterator first, ElementIterator last, ElementComparator comp){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ElementIterator > reorder_iterator< ElementIterator > {\b trsl::sort_iterator} (ElementIterator first, ElementIterator last){\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a {\b reorder_iterator} that will iterate through a sorted permutation of the population referenced by {\f2 first}  and {\f2 last} . }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b sort_iterator.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include sort__iterator_8hpp.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include weight__accessor_8hpp.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
weight_accessor.hpp File Reference{\comment endTitleHead}
\par \pard\plain 
{\tc\tcl2 \v weight_accessor.hpp}
{\xe \v weight_accessor.hpp}
{\comment writeAnchor (weight__accessor_8hpp)}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b trsl::weight_accessor< WeightType, ElementType >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Weight accessor that always returns 1. }{\comment (endMemberDescription)}
}}
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b trsl::mp_weight_accessor< WeightType, ElementType >}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Method Pointer weight accessor. }{\comment (endMemberDescription)}
}}
{\comment (endMemberList) }
}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces{\comment endGroupHeader}
\par
\pard\plain 

{\comment (startMemberList) }
{
{\comment startMemberItem }
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b trsl}{\comment endMemberItem }
{\comment (newParagraph)}
\par
{\comment startParagraph}
{\comment (newParagraph)}
\par
{
{\comment (startMemberDescription)}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Public namespace. \par
}{\comment (endMemberDescription)}
}}
{\comment endParagraph}
}\par
{\comment (endMemberList) }
}
{\comment (rtfwriteRuler_thin)}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\comment startGroupHeader}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description{\comment endGroupHeader}
\par
\pard\plain 
{\comment startTextBlock}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\comment startParagraph}
{
Definition in file {\b weight_accessor.hpp}.{\comment endParagraph}
}\par
{\comment endTextBlock}
}
{\comment endFile}
{\comment end include weight__accessor_8hpp.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Example Documentation{\tc \v Example Documentation}
\par \pard\plain 
{\comment begin include Particle_8hpp-example.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Particle.hpp{\comment endTitleHead}
\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // (C) Copyright Renaud Detry   2007-2008.{\comment (lineBreak)}
\par
// Distributed under the Boost Software License, Version 1.0. (See{\comment (lineBreak)}
\par
// accompanying file LICENSE_1_0.txt or copy at{\comment (lineBreak)}
\par
// http://www.boost.org/LICENSE_1_0.txt){\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#ifndef TRSL_PARTICLE_HPP{\comment (lineBreak)}
\par
#define TRSL_PARTICLE_HPP{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
namespace trsl \{{\comment (lineBreak)}
\par
  namespace example \{{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    // Example element class.{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    class Particle{\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
    public:{\comment (lineBreak)}
\par
      Particle(double weight, double x, double y) :{\comment (lineBreak)}
\par
        x_(x), y_(y), weight_(weight) \{\}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
      void setWeight(const double weight) \{ weight_ = weight; \}{\comment (lineBreak)}
\par
      double getWeight() const \{ return weight_; \};{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
      bool operator==(const Particle& p) const{\comment (lineBreak)}
\par
        \{ return x_ == p.x_ && y_ == p.y_ && weight_ == p.weight_; \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      bool operator<(const Particle& p) const{\comment (lineBreak)}
\par
        \{ return weight_ < p.weight_; \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      double getX() const \{ return x_; \}{\comment (lineBreak)}
\par
      double getY() const \{ return y_; \}{\comment (lineBreak)}
\par
      {\comment (lineBreak)}
\par
    private:{\comment (lineBreak)}
\par
      double x_;{\comment (lineBreak)}
\par
      double y_;{\comment (lineBreak)}
\par
      double weight_;{\comment (lineBreak)}
\par
    \};{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#endif // include guard{\comment (lineBreak)}
\par
\par}
 \par
}{\comment endFile}
{\comment end include Particle_8hpp-example.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include ParticleCollection_8hpp-example.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ParticleCollection.hpp{\comment endTitleHead}
\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // (C) Copyright Renaud Detry   2007-2008.{\comment (lineBreak)}
\par
// Distributed under the Boost Software License, Version 1.0. (See{\comment (lineBreak)}
\par
// accompanying file LICENSE_1_0.txt or copy at{\comment (lineBreak)}
\par
// http://www.boost.org/LICENSE_1_0.txt){\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#ifndef TRSL_PARTICLECOLLECTION_HPP{\comment (lineBreak)}
\par
#define TRSL_PARTICLECOLLECTION_HPP{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <vector>{\comment (lineBreak)}
\par
#include <trsl/is_picked_systematic.hpp>{\comment (lineBreak)}
\par
#include <trsl/ppfilter_iterator.hpp>{\comment (lineBreak)}
\par
#include <examples/Particle.hpp>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
namespace trsl \{{\comment (lineBreak)}
\par
  namespace example \{{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    // Example population class{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    class ParticleCollection{\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
    public:{\comment (lineBreak)}
\par
      typedef trsl::is_picked_systematic<{\comment (lineBreak)}
\par
        Particle> is_picked;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      typedef trsl::ppfilter_iterator<{\comment (lineBreak)}
\par
        is_picked, std::vector<Particle>::iterator{\comment (lineBreak)}
\par
      > sample_iterator;{\comment (lineBreak)}
\par
      typedef trsl::ppfilter_iterator<{\comment (lineBreak)}
\par
        is_picked, std::vector<Particle>::const_iterator{\comment (lineBreak)}
\par
      > const_sample_iterator;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      ParticleCollection(): totalWeight_(0) \{\}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
      void add(const Particle& p){\comment (lineBreak)}
\par
        \{{\comment (lineBreak)}
\par
          totalWeight_ += p.getWeight();{\comment (lineBreak)}
\par
          particles_.push_back(p);{\comment (lineBreak)}
\par
        \}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
      size_t size() const \{ return particles_.size(); \}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
      sample_iterator sample_begin(size_t sampleSize){\comment (lineBreak)}
\par
        \{{\comment (lineBreak)}
\par
          is_picked predicate(sampleSize, totalWeight_, &Particle::getWeight);{\comment (lineBreak)}
\par
          return sample_iterator(predicate, particles_.begin(), particles_.end());{\comment (lineBreak)}
\par
        \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      sample_iterator sample_end(){\comment (lineBreak)}
\par
        \{{\comment (lineBreak)}
\par
          // For an end of range filter_iterator, the predicate operator(){\comment (lineBreak)}
\par
          // will never be called. We can put anything for sampleSize and{\comment (lineBreak)}
\par
          // populationWeight.  A "random" number should be provided, to{\comment (lineBreak)}
\par
          // avoid a useless call to random().{\comment (lineBreak)}
\par
          is_picked predicate(1, 1, 0, &Particle::getWeight);{\comment (lineBreak)}
\par
          return sample_iterator(predicate, particles_.end(), particles_.end());{\comment (lineBreak)}
\par
        \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      const_sample_iterator sample_begin(size_t sampleSize) const{\comment (lineBreak)}
\par
        \{{\comment (lineBreak)}
\par
          is_picked predicate(sampleSize, totalWeight_, &Particle::getWeight);{\comment (lineBreak)}
\par
          return const_sample_iterator(predicate, particles_.begin(), particles_.end());{\comment (lineBreak)}
\par
        \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
      const_sample_iterator sample_end() const{\comment (lineBreak)}
\par
        \{{\comment (lineBreak)}
\par
          // For an end of range filter_iterator, the predicate operator(){\comment (lineBreak)}
\par
          // will never be called. We can put anything for sampleSize and{\comment (lineBreak)}
\par
          // populationWeight.  A "random" number should be provided, to{\comment (lineBreak)}
\par
          // avoid a useless call to random().{\comment (lineBreak)}
\par
          is_picked predicate(1, 1, 0, &Particle::getWeight);{\comment (lineBreak)}
\par
          return const_sample_iterator(predicate, particles_.end(), particles_.end());{\comment (lineBreak)}
\par
        \}{\comment (lineBreak)}
\par
    private:{\comment (lineBreak)}
\par
      std::vector<Particle> particles_;{\comment (lineBreak)}
\par
      double totalWeight_;{\comment (lineBreak)}
\par
    \};{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#endif // include guard{\comment (lineBreak)}
\par
\par}
 \par
}{\comment endFile}
{\comment end include ParticleCollection_8hpp-example.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include trsl__example1_8cpp-example.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl_example1.cpp{\comment endTitleHead}
\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the most basic example. See {\b trsl_example1plus.cpp}  for a slightly advanced version of this example.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // (C) Copyright Renaud Detry   2007-2008.{\comment (lineBreak)}
\par
// Distributed under the Boost Software License, Version 1.0. (See{\comment (lineBreak)}
\par
// accompanying file LICENSE_1_0.txt or copy at{\comment (lineBreak)}
\par
// http://www.boost.org/LICENSE_1_0.txt){\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//#define TRSL_USE_SYSTEMATIC_INTUITIVE_ALGORITHM{\comment (lineBreak)}
\par
#include <trsl/is_picked_systematic.hpp>{\comment (lineBreak)}
\par
#include <trsl/ppfilter_iterator.hpp>{\comment (lineBreak)}
\par
#include <examples/Particle.hpp>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <vector>{\comment (lineBreak)}
\par
#include <iostream>{\comment (lineBreak)}
\par
#include <numeric> // accumulate{\comment (lineBreak)}
\par
#include <cassert>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
// Type definitions, once and for all.{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
using namespace trsl::example;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
typedef trsl::is_picked_systematic<Particle> is_picked;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
typedef trsl::ppfilter_iterator<{\comment (lineBreak)}
\par
  is_picked, std::vector<Particle>::const_iterator{\comment (lineBreak)}
\par
> sample_iterator;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
int main(){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
  const size_t POPULATION_SIZE = 100;{\comment (lineBreak)}
\par
  const size_t SAMPLE_SIZE = 10;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  // Generate a population //{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  std::vector<Particle> population;{\comment (lineBreak)}
\par
  double totalWeight = 0;{\comment (lineBreak)}
\par
  for (size_t i = 0; i < POPULATION_SIZE; ++i){\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    Particle p(double(rand())/RAND_MAX,  // weight{\comment (lineBreak)}
\par
               double(rand())/RAND_MAX,  // position (x){\comment (lineBreak)}
\par
               double(rand())/RAND_MAX); // position (y){\comment (lineBreak)}
\par
    totalWeight += p.getWeight();{\comment (lineBreak)}
\par
    population.push_back(p);{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
  // Normalize total weight.{\comment (lineBreak)}
\par
  for (std::vector<Particle>::iterator i = population.begin();{\comment (lineBreak)}
\par
       i != population.end(); ++i){\comment (lineBreak)}
\par
    i->setWeight(i->getWeight()/totalWeight);{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  std::vector<Particle> const& const_pop = population;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  //----------------------------//{\comment (lineBreak)}
\par
  // Sample from the population //{\comment (lineBreak)}
\par
  //----------------------------//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  std::vector<Particle> sample;{\comment (lineBreak)}
\par
  // Create the systemtatic sampling functor.{\comment (lineBreak)}
\par
  is_picked predicate(SAMPLE_SIZE, 1.0, &Particle::getWeight);{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  std::cout << "Mean weight: " << 1.0/POPULATION_SIZE << std::endl;{\comment (lineBreak)}
\par
  for (sample_iterator{\comment (lineBreak)}
\par
         sb = sample_iterator(predicate, const_pop.begin(), const_pop.end()),{\comment (lineBreak)}
\par
         si = sb,{\comment (lineBreak)}
\par
         se = sample_iterator(predicate, const_pop.end(),   const_pop.end());{\comment (lineBreak)}
\par
       si != se; ++si){\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    std::cout << "sample_" << std::distance(sb, si) << "'s weight = " <<{\comment (lineBreak)}
\par
      si->getWeight() << std::endl;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    Particle p = *si;{\comment (lineBreak)}
\par
    p.setWeight(1);{\comment (lineBreak)}
\par
    sample.push_back(p);{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    // ... or do something else with *si ...{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
  assert(sample.size() == SAMPLE_SIZE);{\comment (lineBreak)}
\par
  return 0;{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
\par}
 \par
}{\comment endFile}
{\comment end include trsl__example1_8cpp-example.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include trsl__example1plus_8cpp-example.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl_example1plus.cpp{\comment endTitleHead}
\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This example is an "advanced" version of {\b trsl_example1.cpp} . Instead of creating the sample iterators within the code body, we hide the creation detail within a population class.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // (C) Copyright Renaud Detry   2007-2008.{\comment (lineBreak)}
\par
// Distributed under the Boost Software License, Version 1.0. (See{\comment (lineBreak)}
\par
// accompanying file LICENSE_1_0.txt or copy at{\comment (lineBreak)}
\par
// http://www.boost.org/LICENSE_1_0.txt){\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <iostream>{\comment (lineBreak)}
\par
#include <cassert>{\comment (lineBreak)}
\par
#include <functional>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <trsl/is_picked_systematic.hpp>{\comment (lineBreak)}
\par
#include <examples/Particle.hpp>{\comment (lineBreak)}
\par
#include <examples/ParticleCollection.hpp>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
int main(){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
  using namespace trsl::example;{\comment (lineBreak)}
\par
  const size_t POPULATION_SIZE = 100;{\comment (lineBreak)}
\par
  const size_t SAMPLE_SIZE = 10;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  // Generate a population //{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  ParticleCollection population;{\comment (lineBreak)}
\par
  for (size_t i = 0; i < POPULATION_SIZE; ++i){\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    Particle p(double(rand())/RAND_MAX,  // weight{\comment (lineBreak)}
\par
               double(rand())/RAND_MAX,  // position (x){\comment (lineBreak)}
\par
               double(rand())/RAND_MAX); // position (y){\comment (lineBreak)}
\par
    population.add(p);{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  //----------------------------//{\comment (lineBreak)}
\par
  // Sample from the population //{\comment (lineBreak)}
\par
  //----------------------------//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  ParticleCollection sample;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  //-- population contains 100 elements. --//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  for (ParticleCollection::const_sample_iterator{\comment (lineBreak)}
\par
         si = population.sample_begin(SAMPLE_SIZE),{\comment (lineBreak)}
\par
         sb = si,{\comment (lineBreak)}
\par
         se = population.sample_end();{\comment (lineBreak)}
\par
       si != se; ++si){\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    std::cout << "sample_" << std::distance(sb, si) << "'s weight = " <<{\comment (lineBreak)}
\par
      si->getWeight() << std::endl;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    Particle p = *si;{\comment (lineBreak)}
\par
    p.setWeight(1);{\comment (lineBreak)}
\par
    sample.add(p);{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    // ... or do something else with *si ...{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  //-- sample contains 10 elements. --//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  assert(sample.size() == SAMPLE_SIZE);{\comment (lineBreak)}
\par
  return 0;{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
\par}
 \par
}{\comment endFile}
{\comment end include trsl__example1plus_8cpp-example.rtf}
\par \pard\plain 

{\comment BeginRTFSection}
\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
{\comment begin include trsl__example2_8cpp-example.rtf}
{\comment startTitleHead}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trsl_example2.cpp{\comment endTitleHead}
\par \pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid // (C) Copyright Renaud Detry   2007-2008.{\comment (lineBreak)}
\par
// Distributed under the Boost Software License, Version 1.0. (See{\comment (lineBreak)}
\par
// accompanying file LICENSE_1_0.txt or copy at{\comment (lineBreak)}
\par
// http://www.boost.org/LICENSE_1_0.txt){\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
//#define TRSL_USE_BSD_BETTER_RANDOM_GENERATOR{\comment (lineBreak)}
\par
//#define TRSL_USE_SYSTEMATIC_INTUITIVE_ALGORITHM{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <trsl/sort_iterator.hpp>{\comment (lineBreak)}
\par
#include <trsl/is_picked_systematic.hpp>{\comment (lineBreak)}
\par
#include <trsl/random_permutation_iterator.hpp>{\comment (lineBreak)}
\par
#include <trsl/ppfilter_iterator.hpp>{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#include <boost/random/uniform_real.hpp>{\comment (lineBreak)}
\par
#include <boost/random/variate_generator.hpp>{\comment (lineBreak)}
\par
#include <boost/random/mersenne_twister.hpp>{\comment (lineBreak)}
\par
#include <vector>{\comment (lineBreak)}
\par
#include <iostream>{\comment (lineBreak)}
\par
#include <numeric> // accumulate{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
// In this example, population elements are floats, and an element's{\comment (lineBreak)}
\par
// weight is the element itself. The weight accessor is:{\comment (lineBreak)}
\par
double wac(float x){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
  return x;{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
int main(){\comment (lineBreak)}
\par
\{{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  // Generate a population //{\comment (lineBreak)}
\par
  //-----------------------//{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
#define C_ARRAY_ITERATOR_SAMPLING{\comment (lineBreak)}
\par
//#define STD_VECTOR_ITERATOR_SAMPLING{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
#if defined(C_ARRAY_ITERATOR_SAMPLING){\comment (lineBreak)}
\par
  float population[] = \{ 0, 1, 4, 3, 5, 8, 2 \};{\comment (lineBreak)}
\par
  const size_t POPULATION_SIZE = sizeof(population)/sizeof(float);{\comment (lineBreak)}
\par
  const size_t SAMPLE_SIZE = 3;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  typedef float* population_iterator;{\comment (lineBreak)}
\par
  population_iterator populationIteratorBegin(population),{\comment (lineBreak)}
\par
    populationIteratorEnd(population + POPULATION_SIZE);{\comment (lineBreak)}
\par
#elif defined(STD_VECTOR_ITERATOR_SAMPLING){\comment (lineBreak)}
\par
  boost::mt19937 rng;{\comment (lineBreak)}
\par
  boost::uniform_real<float> dist(0, 100);{\comment (lineBreak)}
\par
  boost::variate_generator<{\comment (lineBreak)}
\par
    boost::mt19937&,{\comment (lineBreak)}
\par
    boost::uniform_real<float>{\comment (lineBreak)}
\par
    > uni(rng, dist);{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  const size_t POPULATION_SIZE = 100;{\comment (lineBreak)}
\par
  std::vector<float> population(POPULATION_SIZE);{\comment (lineBreak)}
\par
  std::generate(population.begin(), population.end(), uni);{\comment (lineBreak)}
\par
  const size_t SAMPLE_SIZE = 10;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  typedef std::vector<float>::iterator population_iterator;{\comment (lineBreak)}
\par
  population_iterator populationIteratorBegin = population.begin(),{\comment (lineBreak)}
\par
    populationIteratorEnd = population.end();{\comment (lineBreak)}
\par
#else {\comment (lineBreak)}
\par
#  error Please choose an example.{\comment (lineBreak)}
\par
#endif{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  std::cout << "Population ("{\comment (lineBreak)}
\par
            << std::distance(populationIteratorBegin,{\comment (lineBreak)}
\par
                             populationIteratorEnd){\comment (lineBreak)}
\par
            << " elements):" << std::endl;{\comment (lineBreak)}
\par
  std::copy(populationIteratorBegin,{\comment (lineBreak)}
\par
            populationIteratorEnd,{\comment (lineBreak)}
\par
            std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
  std::cout << std::endl;{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    //----------------------------//{\comment (lineBreak)}
\par
    // Sample from the population //{\comment (lineBreak)}
\par
    //----------------------------//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    typedef trsl::is_picked_systematic<{\comment (lineBreak)}
\par
      float,{\comment (lineBreak)}
\par
      double,{\comment (lineBreak)}
\par
      std::pointer_to_unary_function<float, double>{\comment (lineBreak)}
\par
      > is_picked;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    typedef trsl::persistent_filter_iterator{\comment (lineBreak)}
\par
      <is_picked, population_iterator> sample_iterator;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    is_picked predicate(SAMPLE_SIZE,{\comment (lineBreak)}
\par
                        std::accumulate(populationIteratorBegin,{\comment (lineBreak)}
\par
                                        populationIteratorEnd,{\comment (lineBreak)}
\par
                                        float(0)),{\comment (lineBreak)}
\par
                        std::ptr_fun(wac));{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    sample_iterator sampleIteratorBegin(predicate,{\comment (lineBreak)}
\par
                                        populationIteratorBegin,{\comment (lineBreak)}
\par
                                        populationIteratorEnd);{\comment (lineBreak)}
\par
    sample_iterator sampleIteratorEnd(predicate,{\comment (lineBreak)}
\par
                                      populationIteratorEnd,{\comment (lineBreak)}
\par
                                      populationIteratorEnd);{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    std::cout << "Sample of " << SAMPLE_SIZE << " elements:" << std::endl;{\comment (lineBreak)}
\par
    std::copy(sampleIteratorBegin,{\comment (lineBreak)}
\par
              sampleIteratorEnd,{\comment (lineBreak)}
\par
              std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
    std::cout << std::endl;{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    //-------------------------------------------------------------------//{\comment (lineBreak)}
\par
    // Sample from the population (robust to patterns in the population) //{\comment (lineBreak)}
\par
    //-------------------------------------------------------------------//{\comment (lineBreak)}
\par
    {\comment (lineBreak)}
\par
    typedef trsl::is_picked_systematic<{\comment (lineBreak)}
\par
    float,{\comment (lineBreak)}
\par
    double,{\comment (lineBreak)}
\par
    std::pointer_to_unary_function<float, double>{\comment (lineBreak)}
\par
    > is_picked;{\comment (lineBreak)}
\par
    {\comment (lineBreak)}
\par
    typedef trsl::ppfilter_iterator{\comment (lineBreak)}
\par
    <is_picked, population_iterator> sample_iterator;{\comment (lineBreak)}
\par
    {\comment (lineBreak)}
\par
    is_picked predicate(SAMPLE_SIZE,{\comment (lineBreak)}
\par
                        std::accumulate(populationIteratorBegin,{\comment (lineBreak)}
\par
                                        populationIteratorEnd,{\comment (lineBreak)}
\par
                                        float(0)),{\comment (lineBreak)}
\par
                        std::ptr_fun(wac));{\comment (lineBreak)}
\par
    {\comment (lineBreak)}
\par
    sample_iterator sampleIteratorBegin(predicate,{\comment (lineBreak)}
\par
                                        populationIteratorBegin,{\comment (lineBreak)}
\par
                                        populationIteratorEnd);{\comment (lineBreak)}
\par
    sample_iterator sampleIteratorEnd = sampleIteratorBegin.end();{\comment (lineBreak)}
\par
    {\comment (lineBreak)}
\par
    std::cout << "Probabilistic sample of " << SAMPLE_SIZE << " elements:" << std::endl;{\comment (lineBreak)}
\par
    std::copy(sampleIteratorBegin,{\comment (lineBreak)}
\par
              sampleIteratorEnd,{\comment (lineBreak)}
\par
              std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
    std::cout << std::endl;{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    //-------------------------------------//{\comment (lineBreak)}
\par
    // Get a permutation of the population //{\comment (lineBreak)}
\par
    //-------------------------------------//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    typedef trsl::reorder_iterator{\comment (lineBreak)}
\par
      <population_iterator> permutation_iterator;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
      permutation_iterator pi ={\comment (lineBreak)}
\par
        trsl::random_permutation_iterator(populationIteratorBegin,{\comment (lineBreak)}
\par
                                          populationIteratorEnd);{\comment (lineBreak)}
\par
      {\comment (lineBreak)}
\par
      std::cout << "Permutation:" << std::endl;{\comment (lineBreak)}
\par
      std::copy(pi,{\comment (lineBreak)}
\par
                pi.end(),{\comment (lineBreak)}
\par
                std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
      std::cout << std::endl;{\comment (lineBreak)}
\par
    \}{\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
      permutation_iterator pi ={\comment (lineBreak)}
\par
        trsl::random_permutation_iterator(populationIteratorBegin,{\comment (lineBreak)}
\par
                                          populationIteratorEnd,{\comment (lineBreak)}
\par
                                          SAMPLE_SIZE);{\comment (lineBreak)}
\par
      {\comment (lineBreak)}
\par
      std::cout << "Permutation of a subset of " << SAMPLE_SIZE{\comment (lineBreak)}
\par
                << " elements:" << std::endl;{\comment (lineBreak)}
\par
      std::copy(pi,{\comment (lineBreak)}
\par
                pi.end(),{\comment (lineBreak)}
\par
                std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
      std::cout << std::endl;{\comment (lineBreak)}
\par
    \}{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  \{{\comment (lineBreak)}
\par
    //---------------------//{\comment (lineBreak)}
\par
    // Sort the population //{\comment (lineBreak)}
\par
    //---------------------//{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
    typedef trsl::reorder_iterator{\comment (lineBreak)}
\par
      <population_iterator> permutation_iterator;{\comment (lineBreak)}
\par
  {\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
      permutation_iterator pi ={\comment (lineBreak)}
\par
        trsl::sort_iterator(populationIteratorBegin,{\comment (lineBreak)}
\par
                            populationIteratorEnd);{\comment (lineBreak)}
\par
      {\comment (lineBreak)}
\par
      std::cout << "Sorted population:" << std::endl;{\comment (lineBreak)}
\par
      std::copy(pi,{\comment (lineBreak)}
\par
                pi.end(),{\comment (lineBreak)}
\par
                std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
      std::cout << std::endl;{\comment (lineBreak)}
\par
    \}{\comment (lineBreak)}
\par
    \{{\comment (lineBreak)}
\par
      permutation_iterator pi ={\comment (lineBreak)}
\par
        trsl::sort_iterator(populationIteratorBegin,{\comment (lineBreak)}
\par
                            populationIteratorEnd,{\comment (lineBreak)}
\par
                            std::less<float>(), SAMPLE_SIZE);{\comment (lineBreak)}
\par
      {\comment (lineBreak)}
\par
      std::cout << "Sorted " << SAMPLE_SIZE{\comment (lineBreak)}
\par
                << " smallest elements:" << std::endl;{\comment (lineBreak)}
\par
      std::copy(pi,{\comment (lineBreak)}
\par
                pi.end(),{\comment (lineBreak)}
\par
                std::ostream_iterator<float>(std::cout, " "));{\comment (lineBreak)}
\par
      std::cout << std::endl;{\comment (lineBreak)}
\par
    \}{\comment (lineBreak)}
\par
  \}{\comment (lineBreak)}
\par
{\comment (lineBreak)}
\par
  return 0;{\comment (lineBreak)}
\par
\}{\comment (lineBreak)}
\par
\par}
 \par
}{\comment endFile}
{\comment end include trsl__example2_8cpp-example.rtf}

{\comment BeginRTFChapter}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
{\comment endFile}
}